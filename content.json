{"pages":[],"posts":[{"title":"对lambda演算的一点粗浅的理解 Part1","text":"&emsp; 这个星期一直在看关于lambda演算的的相关内容，算是对里面的一些定义有了基本的了解。这个东西属实神奇，将抽象出来的数学符号全部划归为函数的表现形式、仅仅通过完整的字符串替换就能推出几乎一切的事物与规则。这是我以前从未接触过的。在尖塔又一局通关之后，暂时放下还没肝完的若干个ddl，我还是决定写下一点粗浅的理解。 逻辑&emsp; 我认为逻辑这方面的定义是最贴近直觉也是最容易理解的。&emsp; 首先有关于真和假的定义。12TRUE = \\x.\\y.xFALSE = \\x.\\y.y&emsp; 这个东西比较贴近我们的直觉，因为本来TRUE和FALSE就是我们自己定义出来的。在上面这个定义中，我们可以把这两个东西看成有两个参数的函数，TRUE永远返回第一个，而FALSE永远返回第二个。仔细想想，这个函数可能蕴含了真假……对立统一的哲理。 &emsp; 然后就是一些逻辑连接词的定义。12AND = \\p.\\q.p q pOR = \\p.\\q.p p q&emsp; 从形式上看，这两个函数的调用应该是AND/OR A B的形式。AND函数接受了A和B的两个参数，如果我们把它代进去就得到A B A的形式，展开第一个A，B和A刚好是A的定义中的两个参数，如果A是个TRUE，则返回B；如果A是个FALSE，则返回A。OR也是这样的道理。AND和OR在我的理解中，其实是针对TRUE和FALSE的一种结果相反、但形式相似的运算。 1NOT = \\p.\\a.\\b. p b a &emsp; NOT和AND/OR不一样的地方在于它只有一个参数。尝试计算NOT TRUE，得到\\a.\\b.TRUE b a，我们发现这一步a和b成了TRUE中的两个参数。前面的\\a.\\b.为这个式子保留了函数化（这个说法应该不准确）的特征，而后面倒过来的b a刚好把给出的逻辑值的定义取了反。这样AND的功能得以实现。其实这种设计巧妙地利用了参数的无差别性，通过外层定义的参数可以解开内层的函数；又充分利用了里面的参数函数的性质，外层的参数代入的时候借助了内层函数的不同实现了不同的功能。这种设计在lambda演算中处处存在，我觉得自己仍然无法理解其设计逻辑，只能先拼命鼓个掌。 &emsp; 我们在上面发现了AND和OR的形式其实很相像，只是最后的两个参数取反了而已。看到NOT的定义的时候，也会很想把最后的b a取个反，这个东西定义为IF。1IF = \\p.\\a.\\b. p a b&emsp; 我一开始并不是很能理解这个东西的命名，既然它和NOT非常相像，那么我们也尝试代入一个参数。考虑IF TRUE，得到\\a.\\b.TRUE a b，这个东西算出来就和我们代进去的东西一样了。&emsp; 那么为什么这个东西叫做IF呢？我们一般程序中的IF语句的语法是IF A do B.。其中A是一个最终转化为逻辑值的东西，而B是我们要做的事情，我们一开始给了IF一个逻辑值，如果我们再尝试给上面的IF一个要做的事情（依然记作A），那么就是计算IF TRUE A，得到\\b.TRUE A b，A代入TRUE就得到\\b.A。也就是说，不管后面那个B，这都是一个返回要做的事情的函数了。&emsp; 这个东西……看上去并不是那么好用，因为外层套了一个东西，所以还不能马上得到要做的事情。回到IF的那个表达式，发现最后两个参数a和b的地位应该是差不多的。既然我们只给了它一个要做的事情似乎打破了这样的平衡，为了维持形式的平衡感，不妨再给它一个B。这样子就变成了IF TRUE A B，会返回我们要做的事情A；而当我们尝试计算IF FALSE A B时，返回值就是我们另一件要做的事情B了。这和IF...ELSE...的语义不谋而合。&emsp; 如果把前面的那个TRUE和FALSE换成一个逻辑表达式的话，我们就好像实现了真正的IF语句。这样子一来，IF这个名字名副其实。至于为什么把NOT的最后两个变量反过来就变成了IF，我确实是不知道，这没有和我脑子里任何一条任何一个学科的可能沾边的知识联系起来。可能这里蕴含了我尚未了解甚至尚未发现的某种真理；也有可能，NOT和IF这两件事情本来是统一的，这里只是恰好从两个方向对这两件事情进行理解给了两个没啥联系的名字而已。 自然数&emsp; lambda演算中的自然数是根据皮亚诺公理定义的，在这个定义中只需要一个ZERO和一个后继函数SUCC就可以表示所有的自然数了。12ZERO = \\f.\\x.xSUCC = \\n.\\f.\\x. f(n f x)&emsp; ZERO可以看成含有两个参数的函数，它永远返回第二个参数。一种理解的方式是将后面的那个x理解为ZERO，而前面的那个f理解为一个后继函数。f和x只不过是一个名字，任何名字都可以，所以把这个东西写成函数的形式。&emsp; 按照这个说法，我们可以尝试写一下后面的数字。123ONE = \\f.\\x.f xTWO = \\f.\\x.f(f x)THREE = \\f.\\x.f(f(f x))&emsp; 有几个数字就有几个f，这也和直觉很接近。&emsp; 在理解SUCC时，还是采取尝试计算的方式。假设我们给了它一个参数N，也就是SUCC N，就等于\\f.\\x. f(N f x)，在这里式子中我们展开N，后面的f和x都是N的参数，所以这个(N f x)解开了所有的参数，变成了一个只有f和x的不是函数化的N，然后再在外面套上了一个f，结合最外层的\\f.\\x.,它重新变成了函数的形式。&emsp; 不过在这里我还是先通过计算SUCC ZERO得到了ONE的定义，然后再计算SUCC ONE得到了TWO的定义并找到了规律，上面的描述其实是事后的一点理解。&emsp; 有了数字，我们尝试定义基本的运算，加法和乘法。12PLUS = \\m.\\n. m SUCC nMULT = \\m.\\n.\\f. m (n f)&emsp; 加法的定义比较容易理解。在这个式子中SUCC和n都是m的参数，它将m展开后的所有f都变成了SUCC，然后最内层的x变成了n。这就相当于对n做m次SUCC，得到的数就是n + m。&emsp; 乘法的这个定义也差不多。加法是需要得到f^{n+m}(x) = f^n(x) * f^m(x)，而乘法需要得到f^{n * m}(x) = (f^{n}(x))^{m}；加法把m外层的f全部替换为了SUCC，而乘法只需要把m外层的每一个f替换为n层f。&emsp; 观察MULT的定义，(n f)解开了m的第一层参数。式子变成了这样。1\\f.\\x. (n f)((n f) ... (n f x)) &emsp; 其中外层的f是MULT定义中的f，而内层的x来自于我们代入的m。我们观察最内层的(n f x)，在这里f和x依然作为n的两个参数，代入之后得到了不是函数形式的n（这里记为n1），然后再观察上一层(n f) n1，我们发现f和n1成为了上一层n的两个参数，再次代入，发现这是在n1的外层又多套了n个f。以此类推，我们最后给一个x套上了mn层的括号，这就是MULT了。&emsp; 从这里我们也可以发现一些性质，比如n f其实是将f这件事情应用n遍。m SUCC n是将SUCC这件事情重复了m遍然后应用再到n上，(n f)是将f这件事情应用n遍，而m (n f)是将(n f)这件事情应用m遍。但是在这样子的理解中，我们把m理解成了一个数字，而(n f)这个东西理解为了一件要做的事情。所以这样子的理解应该是没什么实际价值，我觉得这样子理解的主要用处就是可以加深我们的印象，使得lambda表达式更有规律性一些。&emsp; 另一个令人意想不到的东西是POW。1POW = \\b.\\e.e b&emsp; POW确实难以理解，我们的第一想法应该是要把MULT这个事情重复n次，然而这个式子好像并没有体现出这一点。&emsp; 我们尝试计算POW M N，这个式子的结果是m ^ n。代入M，得到N M；展开N，M是N中f这个参数，得到\\x. M(M(M ... (M x)))，一共有N个M；依然是先看最里面那个括号(M x)，x是M中的f参数，得到\\x1.x(x(x ... (x x1)))，这个式子中一共有M个x，这里为了区分，我们把M中的那个x参数重新记作x1（\\alpha变换）；将第一个括号中的结果（暂时记作T）代入第二个括号M (\\x1.x(x(x ... (x x1))))，依然是展开f参数，得到\\x2.T(T(T ... (T x2)))；还是先看最里面的括号，我们发现这个x2成为了T中的x1参数，展开(T x2) = x(x(x ... (x x2)))，这里一共有了M个x，然后再用我们刚刚算出来的这个东西展开第二层的T，相当于在x(x(x … (x x2)))的外面又套上了M层x，如此操作过后，我们拆开了第一个式子的两个括号，得到了M^2层x套上一个x2的东西。到这个地方规律已经出现，我们依次拆开N层M，每拆一层，我们就把上一层的每一个x变成M个x，最里面的x1被迭代为x2，最终被迭代为xN，最后就变成了\\x.\\xN.x(x(x ... (x xN)))，这个式子仅仅是把f和x换个名字，确实是m ^ n次的表达式。&emsp; 这个式子相当简洁又相当神奇，如果我们把e和b都理解成字符串，它其实就是个SWAP。回想我们上面发现的那个规律，这个式子的意思应该是把M应用N遍，把M看成一个函数的话，也就是说M ^ N。再仔细思考一下POW这个表达式，如果我们也给出\\f.\\x.这两个参数呢？POW = \\m.\\n.\\f.\\x. n m f x，这个式子就很清楚表达了POW的含义了。&emsp; 从这个想法中得到启发，我们可以给出PLUS，MULT，POW的统一定义。123PLUS = \\m.\\n.\\f.\\x. m f(n f x)MULT = \\m.\\n.\\f.\\x. m (n f x) xPOW = \\m.\\n.\\f.\\x. n m f x&emsp; 注意到写在最后的f和x是没用的，完全可以删掉。MULT和POW都是我们熟悉的形式，PLUS则不一样，这也是PLUS的另一种定义。&emsp; 还注意到其实SUCC也是PLUS的一种+1的特殊情况，我们把PLUS中的m代入1，就刚好得到了SUCC的定义。&emsp; 定义了加法，我们考虑定义减法，考虑先定义前驱函数PRED。1PRED = \\n.\\f.\\x. n(\\g.\\h. h(g f))(\\u.x)(\\u.u)&emsp; 这个东西……确实是比较不好理解，我一开始尝试计算PRED N的时候把最后那个(\\u.u)代到f里面去了，然后就怎么算都不对，两天时间看了好多遍，最后把括号全部都写了一下才发现错了。qaq&emsp; 尝试计算PRED N，N可以解开最外层的n，代入得到\\f.\\x. N(\\g.\\h. h(g f))(\\u.x)(\\u.u)；这个时候能能动的只有展开N了，那么后面的(\\g.\\h. h(g f))（记为A）就成为了N中的f，而N中也有个x与前面冲突了，我们把它写作y，展开得到\\f.\\x.(\\y.A(A(A ... (A y))))(\\u.x)(\\u.u)；依然是先看最里面的括号A y，代入得到\\h. h(y f)；这个东西代到上一层的g里面去，得到\\h'.h'(\\h.h(y f))；又看出了规律，每代一层就套上\\h.h()这么一个东西，最后的形式就是\\f.\\x.((\\y.\\hN.hN(...\\h1.h1(y f)))(\\u.x))(\\u.u)，我们把(\\u.x)代进y里面去，\\f.\\x.(\\hN.hN(...\\h1.h1((\\u.x) f)))(\\u.u) = \\f.\\x.(\\hN.hN(...\\h1.h1(x)))；然后我们把(\\u.u)代进\\hN.hN(...)里面去，解开了最外面一层的h，这样子还剩下N - 1层h，注意到每一个A都在结尾处产生了一个f，把f一个一个代入到h{N - 1}、h{N - 2}、\\cdots、h1里面去，我们就得到了\\f.\\x.f(f(f ... (f x)))，一共有N - 1个括号，这恰好是N - 1。&emsp; 特别的，PRED ZERO = ZERO。这件事情只要把ZERO代到上面的N里面去验证一下就可以了，事实上当N取ZERO的时候那堆h根本就不存在，\\f.\\x.((\\y.y)(\\u.x))(\\u.u) = \\f.\\x.x = ZERO。&emsp; 有了PRED，我们就可以写SUB了，和PLUS一个道理。1SUB = \\m.\\n. n PRED m&emsp; 在这样的定义下，需要注意的是N > M时，SUB M N = ZERO。&emsp; 至于PRED这个东西到底是怎么来的，我还不太明白，可以去看维基的church_excoding词条，里面有对这一整套东西都有简洁而清楚的描述。 关系符号&emsp; 有了数字和加减法，我们终于学会了算数，然而在这样的数字系统中还有一块重要的内容是关系符号（RELOP，这样子描述应该不准确吧）。&emsp; 我们常用的一共有6个表示关系的符号，有了基本的逻辑运算，我们只需要定义其中的一个，就可以把剩下的全部都表示出来。但是在这之前，我们至少要有一个判定一个数是否为0的函数。&emsp; 首先定义ISZERO。1ISZERO = \\n.n (\\x.FALSE) TRUE&emsp; 尝试计算ISZERO N，我们发现(\\x.FALSE)和TRUE是N中的两个参数，代入得到(\\x.FALSE)((\\x.FALSE) ... ((\\x.FALSE) TRUE))，只要这个N里面出现一个f，那么这个函数就会返回FALSE，否则就是TRUE。&emsp; 借助于不能减为负数的性质，我们可以方便地定义LEQ。1LEQ = \\n.\\m. ISZERO (SUB n m)那么EQ也可以定义了。1EQ = \\m.\\n. (LEQ m n) AND (LEQ n m)&emsp; 构建了基本的东西之后，这个东西终于变成我们熟悉的编程语言的形式了。不容易啊。","link":"/2021/03/28/%E5%AF%B9lambda%E6%BC%94%E7%AE%97%E7%9A%84%E4%B8%80%E7%82%B9%E7%B2%97%E6%B5%85%E7%9A%84%E7%90%86%E8%A7%A3_PART1/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/03/25/hello-world/"}],"tags":[{"name":"lambda演算","slug":"lambda演算","link":"/tags/lambda%E6%BC%94%E7%AE%97/"}],"categories":[{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]}